import pandas as pdimport numpy as npimport torchimport torch.nn as nnimport os# --- 1. å®šç¾©æ¨¡å‹æ¶æ§‹ (å¿…é ˆèˆ‡è¨“ç·´æ™‚å®Œå…¨ä¸€è‡´) ---class MathDeptCNN(nn.Module):    def __init__(self):        super(MathDeptCNN, self).__init__()        self.feature_extractor = nn.Sequential(            nn.Conv1d(1, 32, kernel_size=3, padding=1),            nn.BatchNorm1d(32),            nn.ReLU(),            nn.MaxPool1d(2),            nn.Conv1d(32, 64, kernel_size=3, padding=1),            nn.BatchNorm1d(64),            nn.ReLU(),            nn.AdaptiveAvgPool1d(1)        )        self.classifier = nn.Sequential(            nn.Dropout(0.3),            nn.Linear(64, 2)        )    def forward(self, x):        if x.dim() == 4: x = x.squeeze(2)        x = self.feature_extractor(x)        x = x.view(x.size(0), -1)        return self.classifier(x)# --- 2. é‘‘å®šé‚è¼¯å°è£ ---class MathDeptEvaluator:    def __init__(self, model_path):        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")        self.model = MathDeptCNN().to(self.device)        if os.path.exists(model_path):            self.model.load_state_dict(torch.load(model_path, map_location=self.device))            self.model.eval()            print(f"âœ… æˆåŠŸåŠ è¼‰æ¨¡å‹æ¬Šé‡: {model_path}")        else:            raise FileNotFoundError(f"âŒ æ‰¾ä¸åˆ°æ¨¡å‹æª”æ¡ˆ: {model_path}")    def evaluate(self, csv_path):        df = pd.read_csv(csv_path)        feature_cols = [f'Bin_{i*10}-{i*10+9 if i<9 else 100}' for i in range(10)]        core_keywords = ['å¾®ç©åˆ†', 'ç·šæ€§ä»£æ•¸', 'ä»£æ•¸', 'åˆ†æ', 'å¹¾ä½•', 'æ‹“æ¨¸', 'å¾®åˆ†']        core_probs, gen_probs = [], []        for _, row in df.iterrows():            bins = np.nan_to_num(row[feature_cols].values.astype(float), nan=0.0)            if bins.sum() == 0: continue            # æ•¸æ“šæ¨™æº–åŒ–            input_tensor = (torch.tensor(bins, dtype=torch.float32) / (bins.sum() + 1e-8)).view(1, 1, 10).to(self.device)            with torch.no_grad():                prob = torch.softmax(self.model(input_tensor), dim=1)[0][1].item()            if any(key in str(row['èª²ç¨‹åç¨±']) for key in core_keywords):                core_probs.append(prob)            else:                gen_probs.append(prob)        # è¨ˆç®—å¾—åˆ†        avg_core = np.mean(core_probs) if core_probs else 0        avg_gen = np.mean(gen_probs) if gen_probs else 0        final_score = (avg_core * 0.6 + avg_gen * 0.4) * 100        # ç­‰ç´šåˆ¤å®š        if final_score >= 70: rank = "S+ (Global Elite) ğŸŒŸ"        elif final_score >= 50: rank = "A (Strong Research) ğŸ’"        elif final_score >= 30: rank = "B (Standard Academic) ğŸ“š"        else: rank = "C (Needs Improvement) âš ï¸"        print(f"\n" + "="*40)        print(f"ğŸ›ï¸  æ•¸å­¸ç³»å¯¦åŠ›é‘‘å®šå ±å‘Š ({os.path.basename(csv_path)})")        print("="*40)        print(f"é‘‘å®šç­‰ç´šï¼š{rank}")        print(f"ç¶œåˆå¾—åˆ†ï¼š{final_score:.2f}")        print(f"æ ¸å¿ƒèª²ç¨‹ï¼š{len(core_probs)} é–€ (å¹³å‡é ‚å°–ç‡: {avg_core*100:.2f}%)")        print(f"ä¸€èˆ¬èª²ç¨‹ï¼š{len(gen_probs)} é–€ (å¹³å‡é ‚å°–ç‡: {avg_gen*100:.2f}%)")        print("="*40 + "\n")# --- 3. åŸ·è¡Œä¸»ç¨‹å¼ ---if __name__ == "__main__":    # ç¢ºä¿ math_dept_cnn_v1.pth æ”¾åœ¨åŒä¸€å€‹è³‡æ–™å¤¾    evaluator = MathDeptEvaluator('math_dept_cnn_v1.pth')    # å¡«å…¥ä½ æƒ³è¦é‘‘å®šçš„ CSV è·¯å¾‘    target_csv = 'test_department.csv'    if os.path.exists(target_csv):        evaluator.evaluate(target_csv)    else:        print(f"ğŸ’¡ è«‹å°‡è¦é‘‘å®šçš„æˆç¸¾ CSV å‘½åç‚º {target_csv} æˆ–ä¿®æ”¹ç¨‹å¼ç¢¼ä¸­çš„è·¯å¾‘ã€‚")        